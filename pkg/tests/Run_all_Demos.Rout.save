
R version 2.11.0 (2010-04-22)
Copyright (C) 2010 The R Foundation for Statistical Computing
ISBN 3-900051-07-0

R est un logiciel libre livré sans AUCUNE GARANTIE.
Vous pouvez le redistribuer sous certaines conditions.
Tapez 'license()' ou 'licence()' pour plus de détails.

R est un projet collaboratif avec de nombreux contributeurs.
Tapez 'contributors()' pour plus d'information et
'citation()' pour la façon de le citer dans les publications.

Tapez 'demo()' pour des démonstrations, 'help()' pour l'aide
en ligne ou 'help.start()' pour obtenir l'aide au format HTML.
Tapez 'q()' pour quitter R.

REvolution R enhancements not installed.  For improved
performance and other extensions: apt-get install revolution-r

> library(RcompHam94)
Le chargement a nécessité le package : FKF
Le chargement a nécessité le package : fracdiff
> 
> sourceDir <- function(path, trace = TRUE, ...) {
+          for (nm in list.files(path, pattern = "\\.[RrSsQq]$")) {
+             if(trace) cat("#######################\n###",nm,"\n#######################\n")           
+             source(file.path(path, nm), ...)
+             if(trace) cat("\n")
+          }
+       }
> 
> sourceDir(path="../demo/", trace = TRUE, echo=TRUE) 
#######################
### p112.R 
#######################

> data(gnp1996, package = "RcompHam94")

> selection <- subset(gnp1996, Quarter >= "1947-01-01" & 
+     Quarter <= "1988-10-01")

> y <- diff(log(selection$GNPH))

> max.lags <- 20

> T <- length(y)

> threshold <- 2/sqrt(T)

> gammas <- vector(mode = "numeric", length = max.lags + 
+     1)

> gammas[[1]] <- 1/T * t(y - mean(y)) %*% (y - mean(y))

> for (j in 1:max.lags) gammas[j + 1] <- 1/T * t((y - 
+     mean(y))[(j + 1):T]) %*% (y - mean(y))[1:(T - j)]

> rhos <- gammas/gammas[[1]]

> subscripts <- outer(seq(1, max.lags), seq(1, max.lags), 
+     function(i, j) {
+         abs(i - j)
+     })

> GAMMA <- array(gammas[as.vector(subscripts) + 1], 
+     c(max.lags, max.lags))

> alphas <- vector(mode = "numeric", length = max.lags)

> for (m in 1:max.lags) alphas[m] <- solve(GAMMA[1:m, 
+     1:m], gammas[2:(m + 1)])[[m]]

> screens <- split.screen(figs = c(2, 1))

> screen(n = screens[[1]], new = TRUE)

> par(mar = c(4, 2, 1, 2), cex = 0.75)

> plot(data.frame(i = seq(0, max.lags), rhos = rhos), 
+     type = "h", xlab = "Figure 4.2(a) Sample autocorrelations", 
+     ylab = "", lwd = 5, le .... [TRUNCATED] 

> lines(c(0, max.lags), c(threshold, threshold))

> lines(c(0, max.lags), -c(threshold, threshold))

> lines(c(0, max.lags), c(0, 0))

> screen(n = screens[[2]], new = TRUE)

> par(mar = c(4, 2, 1, 2), cex = 0.75)

> plot(data.frame(i = seq(0, max.lags), alphas = c(1, 
+     alphas)), type = "h", xlab = "Figure 4.2(b) Sample partial autocorrelations", 
+     ylab .... [TRUNCATED] 

> lines(c(0, max.lags), c(threshold, threshold))

> lines(c(0, max.lags), -c(threshold, threshold))

> lines(c(0, max.lags), c(0, 0))

> close.screen(all = TRUE)

> acf.correlation <- acf(y, lag.max = max.lags, type = "correlation", 
+     plot = FALSE, demean = TRUE)

> print(as.vector(acf.correlation$acf))
 [1]  1.00000000  0.34509475  0.17817758 -0.02537843 -0.14230681 -0.18827409
 [7] -0.11613672 -0.09335581 -0.04441490  0.03902657  0.05412612  0.03788102
[13] -0.12386994 -0.12725888 -0.10256196 -0.10719806  0.05022865  0.07874423
[19]  0.10451845  0.05540046  0.07001701

> print(rhos)
 [1]  1.00000000  0.34509475  0.17817758 -0.02537843 -0.14230681 -0.18827409
 [7] -0.11613672 -0.09335581 -0.04441490  0.03902657  0.05412612  0.03788102
[13] -0.12386994 -0.12725888 -0.10256196 -0.10719806  0.05022865  0.07874423
[19]  0.10451845  0.05540046  0.07001701

> acf.partial <- acf(y, lag.max = max.lags, type = "partial", 
+     plot = FALSE, demean = TRUE)

> print(as.vector(acf.partial$acf))
 [1]  0.345094750  0.067075208 -0.120748043 -0.128609341 -0.096659383
 [6]  0.006935269 -0.040052970 -0.027544630  0.043507786  0.007543470
[11] -0.020592065 -0.186352407 -0.053599417  0.009939122 -0.066137883
[16]  0.093638650  0.007111983  0.016895000 -0.045185857  0.023227306

> print(alphas)
 [1]  0.345094750  0.067075208 -0.120748043 -0.128609341 -0.096659383
 [6]  0.006935269 -0.040052970 -0.027544630  0.043507786  0.007543470
[11] -0.020592065 -0.186352407 -0.053599417  0.009939122 -0.066137883
[16]  0.093638650  0.007111983  0.016895000 -0.045185857  0.023227306

#######################
### p15.R 
#######################

> T <- 20

> w <- 1 * (1:20 == 3)

> y <- array(dim = c(T, 2))

> y[1:2, ] <- 0

> phi <- array(c(0.6, 0.2, 0.5, -0.8), c(2, 2))

> for (j in 3:T) y[j, ] <- apply(X = phi * y[(j - 1):(j - 
+     2), ], MARGIN = 2, FUN = sum) + w[j]

> screens <- split.screen(figs = c(2, 1))

> for (i in 1:2) {
+     screen(n = screens[i], new = TRUE)
+     plot(1:T, y[, i], type = "h", xlab = paste("f1 = ", phi[i, 
+         1], ", f2 = ", .... [TRUNCATED] 

> close.screen(all = TRUE)

#######################
### p167.R 
#######################

> data(indprod, package = "RcompHam94")

> selection <- subset(indprod, Month >= "1947-01-01" & 
+     Month <= "1989-11-01")

> raw.data <- selection$IPMFG6

> logdiff.data <- 100 * diff(log(raw.data), lag = 1)

> yeardiff.data <- 100 * diff(log(raw.data), lag = 12)

> s.Y.omega <- function(omega, gammas, params) {
+     1/(2 * pi) * (gammas[[1]] + 2 * as.numeric(t(gammas[-1]) %*% 
+         cos(1:(length(gammas) - .... [TRUNCATED] 

> s.Y.omega.Bartlett <- function(omega, gammas, params) {
+     1/(2 * pi) * (gammas[[1]] + 2 * as.numeric(t((1 - 1:params/(params + 
+         1)) *  .... [TRUNCATED] 

> generate.plot.data <- function(values, estimator, 
+     params) {
+     T <- length(values)
+     acf.covariance <- acf(values, lag.max = T - 1, ty .... [TRUNCATED] 

> raw.s.Y.omega <- generate.plot.data(raw.data, s.Y.omega, 
+     NULL)

> logdiff.s.Y.omega <- generate.plot.data(logdiff.data, 
+     s.Y.omega.Bartlett, 12)

> yeardiff.s.Y.omega <- generate.plot.data(yeardiff.data, 
+     s.Y.omega.Bartlett, 12)

> screens <- split.screen(figs = c(2, 2))

> screen(n = screens[[1]], new = TRUE)

> par(mar = c(4, 2, 1, 2), cex = 0.75)

> plot(selection$Month, raw.data, type = "l", xlab = "Figure 6.3 - FRB IP Index, NSA", 
+     ylab = "")

> screen(n = screens[[2]], new = TRUE)

> par(mar = c(4, 2, 1, 2), cex = 0.75)

> plot(1:length(raw.s.Y.omega), raw.s.Y.omega, type = "l", 
+     xlab = "Figure 6.4 - Value of j", ylab = "")

> screen(n = screens[[3]], new = TRUE)

> par(mar = c(4, 2, 1, 2), cex = 0.75)

> plot(1:length(logdiff.s.Y.omega), logdiff.s.Y.omega, 
+     type = "l", xlab = "Figure 6.5 - Value of j", ylab = "")

> screen(n = screens[[4]], new = TRUE)

> par(mar = c(4, 2, 1, 2), cex = 0.75)

> plot(1:length(yeardiff.s.Y.omega), yeardiff.s.Y.omega, 
+     type = "l", xlab = "Figure 6.6 - Value of j", ylab = "")

> close.screen(all = TRUE)

> args(spectrum)
function (x, ..., method = c("pgram", "ar")) 
NULL

> sp <- spectrum(raw.data, plot = FALSE, span = 10)

> x <- 100 * diff(log(raw.data))

> sp2 <- spectrum(x, span = 6, plot = FALSE)

> x12 <- 100 * diff(log(raw.data), lag = 12)

> sp3 <- spectrum(x12, span = 20, plot = FALSE)

> opar <- par(mfrow = c(2, 2), mar = c(4, 2, 1, 2), 
+     cex = 0.75)

> plot(selection$Month, raw.data, type = "l", xlab = "Figure 6.3 - FRB IP Index, NSA", 
+     ylab = "")

> plot(1:length(sp$spec), sp$spec, type = "l", xlab = "Value of j", 
+     ylab = "")

> plot(1:length(sp2$spec), sp2$spec, type = "l", xlab = "Figure 6.5 - Value of j", 
+     ylab = "")

> plot(1:length(sp3$spec), sp3$spec, type = "l", xlab = "Figure 6.6 - Value of j", 
+     ylab = "")

> par(opar)

#######################
### p376.R 
#######################

> kalman <- function(H, R, F, x, A, y, Q, xi.1.0, P.1.0) {
+     T <- dim(x)[[2]]
+     P.t.t_1 <- array(dim = c(dim(P.1.0), T + 1))
+     P.t.t_1[, , .... [TRUNCATED] 

> data(coninc, package = "RcompHam94")

> YGR <- diff(log(coninc$GYD82))

> CGR <- diff(log(coninc$GC82))

> y <- t(cbind(YGR - mean(YGR), CGR - mean(CGR)))

> THETA <- c(phic = 0.9, phi1 = 0.9, phi2 = 0.9, g1 = 0.5, 
+     g2 = 0.5, sigc = 0.05^0.5, sig11 = 0.05^0.5, sig22 = 0.05^0.5, 
+     r11 = sd(YGR), .... [TRUNCATED] 

> theta.y.to.params <- function(THETA, y) {
+     params <- list(F = diag(THETA[c("phic", "phi1", "phi2")]), 
+         Q = diag(THETA[c("sigc", "sig1 ..." ... [TRUNCATED] 

> objective <- function(THETA, y) {
+     params <- theta.y.to.params(THETA, y)
+     kalman(params$H, params$R, params$F, params$x, params$A, 
+      .... [TRUNCATED] 

> optimizer.results <- optim(par = THETA, fn = objective, 
+     gr = NULL, y = y, control = list(trace = 0))

> params <- theta.y.to.params(optimizer.results$par, 
+     y)

> smoothed.results <- kalman(params$H, params$R, params$F, 
+     params$x, params$A, y, params$Q, params$xi.1.0, params$P.1.0)

> smoothed.data <- smoothed.results$xi.t.T[1, ]

> plot(coninc$Quarter[-1], (y[1, ])/sd(y[1, ]), type = "l", 
+     lty = 1, ylab = "CGR, YGR, and C")

> lines(coninc$Quarter[-1], (y[2, ])/sd(y[2, ]), lty = 2)

> lines(coninc$Quarter[-1], (smoothed.data - mean(smoothed.data))/sd(smoothed.data), 
+     lty = 3)

> sigmasq <- 2

> params <- list(F = array(c(0, 1, 0, 0), c(2, 2)), 
+     Q = diag(c(sigmasq, 0)), H = array(c(1, 0.8), c(2, 1)), R = array(0, 
+         c(1, 1)), A .... [TRUNCATED] 

> params <- c(params, list(P.1.0 = array(solve(diag(length(params$xi.1.0)^2) - 
+     params$F %x% params$F, as.vector(params$Q)), c(length(params$xi. .... [TRUNCATED] 

> myResults <- kalman(params$H, params$R, params$F, 
+     params$x, params$A, params$y, params$Q, params$xi.1.0, params$P.1.0)

> fkfResults <- FKF::fkf(a0 = params$xi.1.0, P0 = params$P.1.0, 
+     dt = rep(0, length(params$xi.1.0)) %o% 1, Tt = params$F %o% 
+         1, HHt = .... [TRUNCATED] 

> print(myResults$xi.t.t)
          [,1]       [,2]        [,3]     [,4]     [,5]
[1,] 0.3048780 -0.1951600  1.02502699 1.100137 2.031900
[2,] 0.2439024  0.2439500 -0.03128374 1.124828 1.210125

> print(fkfResults$att)
          [,1]       [,2]        [,3]     [,4]     [,5]
[1,] 0.3048780 -0.1951600  1.02502699 1.100137 2.031900
[2,] 0.2439024  0.2439500 -0.03128374 1.124828 1.210125

#######################
### p410.R 
#######################

> Y <- rt(500, 10)

> objective <- function(nu, Y) {
+     -sum(log(dt(Y, df = nu)))
+ }

> classical.results <- optimize(interval = c(1, 30), 
+     f = objective, Y = Y)

> mu2 <- mean(Y^2)

> nu <- 2 * mu2/(mu2 - 1)

> print(classical.results)
$minimum
[1] 12.13504

$objective
[1] 747.1027


> print(nu)
[1] 13.22100

> compute.estimates <- function(Y, h, interval) {
+     g <- function(Y, THETA) {
+         apply(X = apply(X = Y, MARGIN = 1, FUN = h, THETA = THETA) .... [TRUNCATED] 

> h <- function(Yt, THETA) {
+     nu <- THETA
+     c(Yt^2 - nu/(nu - 2), Yt^4 - 3 * nu^2/((nu - 2) * (nu - 4)))
+ }

> estimates <- compute.estimates(Y %o% 1, h, interval = c(5, 
+     30))

> print(estimates)
$stage.1.results
$stage.1.results$minimum
[1] 13.08848

$stage.1.results$objective
             [,1]
[1,] 4.557397e-06


$stage.2.results
$stage.2.results$minimum
[1] 13.01763

$stage.2.results$objective
             [,1]
[1,] 2.871433e-06


$overidentifying
          [,1]
[1,] 0.9697747


> Yg <- rgamma(500, 10) * sign(runif(500, -1, 1))

> hg <- function(Yt, THETA) {
+     k <- THETA
+     nu <- k
+     mu <- k
+     sigma <- k
+     skew <- 2/sqrt(k)
+     kurt <- 6/k
+     c(Yt^2 - s .... [TRUNCATED] 

> gestimates <- compute.estimates(Yg %o% 1, hg, interval = c(5, 
+     30))

> print(gestimates)
$stage.1.results
$stage.1.results$minimum
[1] 10.04704

$stage.1.results$objective
         [,1]
[1,] 3.534167


$stage.2.results
$stage.2.results$minimum
[1] 10.05153

$stage.2.results$objective
            [,1]
[1,] 0.001534803


$overidentifying
          [,1]
[1,] 0.3810221


#######################
### p448.R 
#######################

> data(gnptbill, package = "RcompHam94")

> print(fdGPH(gnptbill$GNP))
$d
[1] 0.9588756

$sd.as
[1] 0.2427173

$sd.reg
[1] 0.04061276


> print(fdGPH(gnptbill$TBILL))
$d
[1] 0.9511594

$sd.as
[1] 0.2427173

$sd.reg
[1] 0.227921


#######################
### p489.R 
#######################

> print(Newey.West)
function (X, lags) 
{
    S <- 0
    T <- dim(X)[[1]]
    for (lag in lags:1) S <- S + (lags + 1 - lag)/(lags + 1) * 
        t(X[(lag + 1):T, ]) %*% X[1:(T - lag), ]
    1/T * (t(X) %*% X + S + t(S))
}
<environment: namespace:RcompHam94>

> print(Dickey.Fuller)
function (T, rho, sigma.rho, zeta = numeric(0)) 
{
    list(T = T, rho = rho, sigma.rho = sigma.rho, zeta = zeta, 
        rho.stat = T * (rho - 1)/(1 - sum(zeta)), t.stat = (rho - 
            1)/sigma.rho)
}
<environment: namespace:RcompHam94>

> print(Phillips.Perron)
function (T, rho, sigma.rho, s, lambda.hat.sq, gamma0) 
{
    list(T = T, rho = rho, sigma.rho = sigma.rho, s.sq = s^2, 
        lambda.hat.sq = lambda.hat.sq, gamma0 = gamma0, rho.stat = T * 
            (rho - 1) - 1/2 * (T * sigma.rho/s)^2 * (lambda.hat.sq - 
            gamma0), t.stat = (gamma0/lambda.hat.sq)^0.5 * (rho - 
            1)/sigma.rho - 1/2 * (lambda.hat.sq - gamma0) * T * 
            sigma.rho/s/(lambda.hat.sq^0.5))
}
<environment: namespace:RcompHam94>

> print(Wald.F.Test)
function (R, b, r, s2, XtX_1) 
{
    v <- R %*% b - r
    as.numeric(t(v) %*% solve(s2 * R %*% XtX_1 %*% t(R)) %*% 
        v/dim(R)[[1]])
}
<environment: namespace:RcompHam94>

> data(gnptbill, package = "RcompHam94")

> tbill.data <- data.frame(yt = gnptbill$TBILL[-1], 
+     yt_1 = gnptbill$TBILL[-length(gnptbill$TBILL)])

> plot(gnptbill$Quarter, gnptbill$TBILL, type = "l", 
+     xlab = "Figure 17.2 - Nominal Interest Rate", ylab = "")

> case1.lms <- summary(lm(yt ~ 0 + yt_1 + 0, tbill.data))

> case1.DF <- Dickey.Fuller(T = length(tbill.data$yt), 
+     rho = case1.lms$coefficients[["yt_1", "Estimate"]], sigma.rho = case1.lms$coefficients[[ .... [TRUNCATED] 

> print(case1.lms$coefficients)
      Estimate Std. Error  t value      Pr(>|t|)
yt_1 0.9969357 0.01059183 94.12311 1.277207e-146

> print(case1.DF)
$T
[1] 168

$rho
[1] 0.9969357

$sigma.rho
[1] 0.01059183

$zeta
numeric(0)

$rho.stat
[1] -0.5147943

$t.stat
[1] -0.2893034


> case2.lms <- summary(lm(yt ~ 1 + yt_1, tbill.data))

> case2.DF <- Dickey.Fuller(T = length(tbill.data$yt), 
+     rho = case2.lms$coefficients[["yt_1", "Estimate"]], sigma.rho = case2.lms$coefficients[[ .... [TRUNCATED] 

> print(case2.lms$coefficients)
             Estimate Std. Error   t value      Pr(>|t|)
(Intercept) 0.2105899 0.11212302  1.878204  6.210685e-02
yt_1        0.9669104 0.01913305 50.536135 1.013453e-102

> print(case2.DF)
$T
[1] 168

$rho
[1] 0.9669104

$sigma.rho
[1] 0.01913305

$zeta
numeric(0)

$rho.stat
[1] -5.559061

$t.stat
[1] -1.729450


> F <- Wald.F.Test(R = diag(2), b = case2.lms$coefficients[, 
+     "Estimate"], r = c(0, 1), s2 = case2.lms$sigma^2, XtX_1 = case2.lms$cov.unscaled)

> print(F)
[1] 1.806307

> logGNP <- 100 * log(gnptbill$GNP)

> gnp.data <- data.frame(tt = seq(1, length(gnptbill$GNP) - 
+     1), yt = logGNP[-1], yt_1 = logGNP[-length(gnptbill$GNP)])

> plot(gnptbill$Quarter, gnptbill$GNP, type = "l", xlab = "Figure 17.3 - Real GNP", 
+     ylab = "")

> case4.lms <- summary(lm(yt ~ 1 + yt_1 + tt, gnp.data))

> case4.DF <- Dickey.Fuller(T = length(gnp.data$yt), 
+     rho = case4.lms$coefficients[["yt_1", "Estimate"]], sigma.rho = case4.lms$coefficients[["y ..." ... [TRUNCATED] 

> print(case4.lms$coefficients)
               Estimate  Std. Error   t value      Pr(>|t|)
(Intercept) 27.26477184 13.54992552  2.012171  4.582876e-02
yt_1         0.96252203  0.01930452 49.859941 2.076152e-101
tt           0.02753238  0.01520877  1.810296  7.206931e-02

> print(case4.DF)
$T
[1] 168

$rho
[1] 0.962522

$sigma.rho
[1] 0.01930452

$zeta
numeric(0)

$rho.stat
[1] -6.296298

$t.stat
[1] -1.941409


> F <- Wald.F.Test(R = cbind(rep(0, 2), diag(2)), b = case4.lms$coefficients[, 
+     "Estimate"], r = c(1, 0), s2 = case4.lms$sigma^2, XtX_1 = case4. .... [TRUNCATED] 

> print(F)
[1] 2.442251

> case2.PP <- Phillips.Perron(T = length(case2.lms$residuals), 
+     rho = case2.lms$coefficients[["yt_1", "Estimate"]], sigma.rho = case2.lms$coeffi .... [TRUNCATED] 

> print(case2.lms$coefficients)
             Estimate Std. Error   t value      Pr(>|t|)
(Intercept) 0.2105899 0.11212302  1.878204  6.210685e-02
yt_1        0.9669104 0.01913305 50.536135 1.013453e-102

> print(case2.PP)
$T
[1] 168

$rho
[1] 0.9669104

$sigma.rho
[1] 0.01913305

$s.sq
[1] 0.6375998

$lambda.hat.sq
[1] 0.6880069

$gamma0
[1] 0.6300093

$rho.stat
[1] -6.028975

$t.stat
[1] -1.795686


> case4.PP <- Phillips.Perron(T = length(case4.lms$residuals), 
+     rho = case4.lms$coefficients[["yt_1", "Estimate"]], sigma.rho = case4.lms$coeffi .... [TRUNCATED] 

> print(case4.lms$coefficients)
               Estimate  Std. Error   t value      Pr(>|t|)
(Intercept) 27.26477184 13.54992552  2.012171  4.582876e-02
yt_1         0.96252203  0.01930452 49.859941 2.076152e-101
tt           0.02753238  0.01520877  1.810296  7.206931e-02

> print(case4.PP)
$T
[1] 168

$rho
[1] 0.962522

$sigma.rho
[1] 0.01930452

$s.sq
[1] 1.156270

$lambda.hat.sq
[1] 2.117173

$gamma0
[1] 1.135623

$rho.stat
[1] -10.76066

$t.stat
[1] -2.439143


> tbill.data <- list(it = gnptbill$TBILL[-1:-5], delta.it_ = embed(diff(gnptbill$TBILL[-length(gnptbill$TBILL)]), 
+     4), it_1 = gnptbill$TBILL[c(- .... [TRUNCATED] 

> tbill.lms <- summary(lm(it ~ delta.it_ + 1 + it_1, 
+     tbill.data))

> tbill.adf <- Dickey.Fuller(T = length(gnptbill$TBILL) - 
+     5, rho = tbill.lms$coefficients[["it_1", "Estimate"]], sigma.rho = tbill.lms$coeffici .... [TRUNCATED] 

> print(tbill.lms$coefficients)
              Estimate Std. Error   t value      Pr(>|t|)
(Intercept)  0.1954328 0.10863764  1.798942  7.393646e-02
delta.it_1   0.3346654 0.07882340  4.245762  3.705074e-05
delta.it_2  -0.3879736 0.08082096 -4.800408  3.643800e-06
delta.it_3   0.2761332 0.07998276  3.452409  7.130684e-04
delta.it_4  -0.1067090 0.07944645 -1.343156  1.811475e-01
it_1         0.9690445 0.01860387 52.088332 2.094220e-101

> print(tbill.adf)
$T
[1] 164

$rho
[1] 0.9690445

$sigma.rho
[1] 0.01860387

$zeta
delta.it_1 delta.it_2 delta.it_3 delta.it_4 
 0.3346654 -0.3879736  0.2761332 -0.1067090 

$rho.stat
[1] -5.74363

$t.stat
[1] -1.663928


> print(tbill.lms$coefficients[["delta.it_4", "t value"]])
[1] -1.343156

> gnp.data <- list(yt = logGNP[-1:-5], delta.yt_ = embed(diff(logGNP[-length(logGNP)]), 
+     4), yt_1 = logGNP[c(-1:-4, -(length(logGNP):length(logG .... [TRUNCATED] 

> gnp.lms <- summary(lm(yt ~ delta.yt_ + 1 + yt_1 + 
+     t, gnp.data))

> gnp.adf <- Dickey.Fuller(T = length(logGNP) - 5, rho = gnp.lms$coefficients[["yt_1", 
+     "Estimate"]], sigma.rho = gnp.lms$coefficients[["yt_1",  .... [TRUNCATED] 

> F <- Wald.F.Test(R = cbind(rep(0, 2) %o% rep(0, 5), 
+     diag(2)), b = gnp.lms$coefficients[, "Estimate"], r = c(1, 
+     0), s2 = gnp.lms$sigma^ .... [TRUNCATED] 

> print(gnp.lms$coefficients)
               Estimate  Std. Error    t value     Pr(>|t|)
(Intercept) 35.91807717 13.57200191  2.6464834 8.961726e-03
delta.yt_1   0.32908487  0.07769385  4.2356619 3.869829e-05
delta.yt_2   0.20856825  0.08128118  2.5660092 1.122316e-02
delta.yt_3  -0.08424648  0.08182895 -1.0295437 3.048077e-01
delta.yt_4  -0.07453301  0.07879621 -0.9458959 3.456552e-01
yt_1         0.94969015  0.01938565 48.9893326 4.883651e-97
t            0.03783123  0.01521561  2.4863440 1.395295e-02

> print(gnp.adf)
$T
[1] 164

$rho
[1] 0.9496901

$sigma.rho
[1] 0.01938565

$zeta
 delta.yt_1  delta.yt_2  delta.yt_3  delta.yt_4 
 0.32908487  0.20856825 -0.08424648 -0.07453301 

$rho.stat
[1] -13.28363

$t.stat
[1] -2.595211


> print(F)
[1] 3.743228

> t.value <- (1 - gnp.lms$coefficients[["yt_1", "Estimate"]])/gnp.lms$coefficients[["yt_1", 
+     "Std. Error"]]

> print(t.value)
[1] 2.595211

> print((1 - pt(t.value, 164))/2)
[1] 0.002577594

> for (lag in 10:1) {
+     gnp.lm <- lm(yt ~ delta.yt_ + 1 + yt_1 + t, list(yt = logGNP[-1:-(lag + 
+         1)], delta.yt_ = embed(diff(logGNP[-len .... [TRUNCATED] 

> print(lag)
[1] 2

#######################
### p4.R 
#######################

> T <- 20

> w <- 1 * (1:T == 2)

> phis <- c(0.8, -0.8, 1.1, -1.1)

> y <- array(dim = c(T, length(phis)))

> y[1, ] <- rep(0, length(phis))

> for (j in 2:T) y[j, ] <- phis * y[j - 1, ] + w[j]

> print(y[2:T, 1])
 [1] 1.00000000 0.80000000 0.64000000 0.51200000 0.40960000 0.32768000
 [7] 0.26214400 0.20971520 0.16777216 0.13421773 0.10737418 0.08589935
[13] 0.06871948 0.05497558 0.04398047 0.03518437 0.02814750 0.02251800
[19] 0.01801440

> print(phis[[1]]^seq(0, T - 2))
 [1] 1.00000000 0.80000000 0.64000000 0.51200000 0.40960000 0.32768000
 [7] 0.26214400 0.20971520 0.16777216 0.13421773 0.10737418 0.08589935
[13] 0.06871948 0.05497558 0.04398047 0.03518437 0.02814750 0.02251800
[19] 0.01801440

> screens <- split.screen(figs = c(2, 2))

> for (i in 1:length(phis)) {
+     screen(n = screens[[i]], new = TRUE)
+     plot(1:T, y[, i], type = "h", xlab = paste("f = ", phis[[i]]), 
+       .... [TRUNCATED] 

> close.screen(all = TRUE)

#######################
### p50.R 
#######################

> T <- 20

> specifications <- list(list(label = "White Noise", 
+     MA = vector(mode = "numeric"), AR = vector(mode = "numeric")), 
+     list(label = "MA(1)" .... [TRUNCATED] 

> sigmasq <- 1

> specifications[[1]]$rho <- c(1, rep(0, T - 1))

> for (i in 2:3) {
+     MA <- specifications[[i]]$MA
+     q <- length(MA)
+     gamma <- vector(mode = "numeric", length = T)
+     gamma[1] <- sigm .... [TRUNCATED] 

> for (i in 4:5) {
+     AR <- specifications[[i]]$AR
+     p <- length(AR)
+     F <- rbind(AR, cbind(diag(p - 1), rep(0, p - 1)))
+     gamma <- vec .... [TRUNCATED] 

> screens <- split.screen(figs = c(3, 2))

> screen.index <- 1

> for (i in 1:length(specifications)) {
+     screen(n = screens[[i]], new = TRUE)
+     specification <- specifications[[i]]
+     par(mar = c(4, 2,  .... [TRUNCATED] 

> close.screen(all = TRUE)

> g3 <- ARMAacf(ar = numeric(0), ma = specifications[[3]]$MA, 
+     lag.max = T, pacf = FALSE)

> print(specifications[[3]]$rho)
 [1]  1.0000000 -0.6666667  0.4871795 -0.3487179  0.1538462  0.0000000
 [7]  0.0000000  0.0000000  0.0000000  0.0000000  0.0000000  0.0000000
[13]  0.0000000  0.0000000  0.0000000  0.0000000  0.0000000  0.0000000
[19]  0.0000000  0.0000000

> print(g3)
         0          1          2          3          4          5          6 
 1.0000000 -0.6666667  0.4871795 -0.3487179  0.1538462  0.0000000  0.0000000 
         7          8          9         10         11         12         13 
 0.0000000  0.0000000  0.0000000  0.0000000  0.0000000  0.0000000  0.0000000 
        14         15         16         17         18         19         20 
 0.0000000  0.0000000  0.0000000  0.0000000  0.0000000  0.0000000  0.0000000 

> g4 <- ARMAacf(ar = specifications[[4]]$AR, ma = numeric(0), 
+     lag.max = T - 1, pacf = FALSE)

> print(specifications[[4]]$rho)
 [1] 1.00000000 0.80000000 0.64000000 0.51200000 0.40960000 0.32768000
 [7] 0.26214400 0.20971520 0.16777216 0.13421773 0.10737418 0.08589935
[13] 0.06871948 0.05497558 0.04398047 0.03518437 0.02814750 0.02251800
[19] 0.01801440 0.01441152

> print(g4)
         0          1          2          3          4          5          6 
1.00000000 0.80000000 0.64000000 0.51200000 0.40960000 0.32768000 0.26214400 
         7          8          9         10         11         12         13 
0.20971520 0.16777216 0.13421773 0.10737418 0.08589935 0.06871948 0.05497558 
        14         15         16         17         18         19 
0.04398047 0.03518437 0.02814750 0.02251800 0.01801440 0.01441152 

#######################
### p51.R 
#######################

> theta <- (-300:300) * 0.01

> corrs <- theta/(1 + theta^2)

> plot(theta, corrs, type = "l")

> grid(nx = 2, ny = 2)

#######################
### p55.R 
#######################

> specifications <- list(list(label = "f = 0", MA = vector(mode = "numeric"), 
+     AR = vector(mode = "numeric")), list(label = "f = .5", MA = vecto .... [TRUNCATED] 

> T <- 100

> epsilon <- rnorm(T, 0, 1)

> simulate.forward <- function(specification, epsilon) {
+     T <- length(epsilon)
+     AR <- specification$AR
+     MA <- specification$MA
+     pr .... [TRUNCATED] 

> for (i in 1:length(specifications)) specifications[[i]]$Y <- simulate.forward(specifications[[i]], 
+     epsilon)

> screens <- split.screen(figs = c(3, 1))

> screen.index <- 1

> for (i in 1:length(specifications)) {
+     screen(n = screens[[i]], new = TRUE)
+     specification <- specifications[[i]]
+     par(mar = c(4, 2,  .... [TRUNCATED] 

> close.screen(all = TRUE)

> for (specification in specifications) {
+     AR <- specification$AR
+     MA <- specification$MA
+     shift <- max(length(AR), length(MA))
+     Y .... [TRUNCATED] 
 [1] -1.3797220  1.0941411 -0.2668330 -0.9189668  0.6796791 -0.7832638
 [7]  0.7609781 -0.1575363 -1.2056859  0.2828525
 [1] -1.3797220  1.0941411 -0.2668330 -0.9189668  0.6796791 -0.7832638
 [7]  0.7609781 -0.1575363 -1.2056859  0.2828525
 [1] -1.37972204  0.40428012 -0.06469294 -0.95131326  0.20402247 -0.68125259
 [7]  0.42035183  0.05263957 -1.17936613 -0.30683053
 [1] -1.37972204  0.40428012 -0.06469294 -0.95131326  0.20402247 -0.68125259
 [7]  0.42035183  0.05263957 -1.17936613 -0.30683053
 [1] -1.3797220 -0.1476087 -0.3996808 -1.2786795 -0.4711325 -1.2072831
 [7] -0.3255766 -0.4505553 -1.6111857 -1.1672146
 [1] -1.3797220 -0.1476087 -0.3996808 -1.2786795 -0.4711325 -1.2072831
 [7] -0.3255766 -0.4505553 -1.6111857 -1.1672146

#######################
### p582.R 
#######################

> data(ppp, package = "RcompHam94")

> selection <- subset(ppp, Month >= "1973-01-01" & Month <= 
+     "1989-10-01")

> ppp.data <- data.frame(Month = selection$Month, pstar = 100 * 
+     log(selection$PC6IT/selection$PC6IT[[1]]), p = 100 * log(selection$PZUNEW/selec .... [TRUNCATED] 

> ppp.data[["rer"]] <- ppp.data$p - ppp.data$ner - ppp.data$pstar

> plot(ppp.data$Month, ppp.data$ner, type = "l", lty = 3, 
+     xlab = "Figure 19.2", ylab = "", ylim = c(-150, 250))

> lines(ppp.data$Month, ppp.data$p, lty = 2)

> lines(ppp.data$Month, ppp.data$pstar, lty = 1)

> plot(ppp.data$Month, ppp.data$rer, type = "l", lty = 1, 
+     xlab = "Figure 19.3", ylab = "")

> do.DF <- function(series, lag) {
+     T <- length(series)
+     df.lms <- summary(lm(yt ~ yt_1 + tt + delta.yt_ + 1, list(yt = series[-1:-(lag + 
+ .... [TRUNCATED] 

> for (series.name in c("p", "pstar", "ner", "rer")) do.DF(series = ppp.data[[series.name]], 
+     lag = 12)
                Estimate  Std. Error     t value      Pr(>|t|)
(Intercept)  0.136160926 0.085779070   1.5873444  1.142502e-01
yt_1         0.994004087 0.003067474 324.0464885 6.323397e-244
tt           0.002927051 0.001766655   1.6568325  9.935541e-02
delta.yt_1   0.553397837 0.075217880   7.3572644  7.109482e-12
delta.yt_2  -0.056908322 0.085440124  -0.6660609  5.062543e-01
delta.yt_3   0.070125117 0.084906900   0.8259060  4.099884e-01
delta.yt_4   0.060389596 0.081969953   0.7367284  4.622797e-01
delta.yt_5  -0.078232496 0.078488461  -0.9967388  3.202754e-01
delta.yt_6  -0.048376861 0.070721885  -0.6840437  4.948576e-01
delta.yt_7   0.165843348 0.068915448   2.4064757  1.715410e-02
delta.yt_8  -0.070207448 0.070014467  -1.0027563  3.173709e-01
delta.yt_9   0.244644550 0.070161410   3.4868819  6.187074e-04
delta.yt_10 -0.110047172 0.072579707  -1.5162251  1.312771e-01
delta.yt_11  0.117580628 0.072937432   1.6120753  1.087579e-01
delta.yt_12  0.046702346 0.068650314   0.6802933  4.972230e-01
$T
[1] 189

$rho
[1] 0.994004

$sigma.rho
[1] 0.003067474

$zeta
 delta.yt_1  delta.yt_2  delta.yt_3  delta.yt_4  delta.yt_5  delta.yt_6 
 0.55339784 -0.05690832  0.07012512  0.06038960 -0.07823250 -0.04837686 
 delta.yt_7  delta.yt_8  delta.yt_9 delta.yt_10 delta.yt_11 delta.yt_12 
 0.16584335 -0.07020745  0.24464455 -0.11004717  0.11758063  0.04670235 

$rho.stat
[1] -10.78352

$t.stat
[1] -1.954675

[1] 2.412933
                Estimate  Std. Error     t value      Pr(>|t|)
(Intercept)  0.768007976 0.253071035   3.0347526  2.776788e-03
yt_1         0.999456707 0.004116999 242.7633949 3.768702e-222
tt          -0.002406065 0.004989081  -0.4822662  6.302229e-01
delta.yt_1   0.420701728 0.076110499   5.5275124  1.170691e-07
delta.yt_2  -0.011592127 0.081521266  -0.1421976  8.870885e-01
delta.yt_3   0.013439685 0.080162382   0.1676558  8.670488e-01
delta.yt_4   0.077206365 0.080125530   0.9635676  3.366000e-01
delta.yt_5  -0.036494296 0.080087139  -0.4556824  6.491866e-01
delta.yt_6   0.145282237 0.078670504   1.8467180  6.648647e-02
delta.yt_7  -0.099118088 0.078839877  -1.2572075  2.103634e-01
delta.yt_8   0.046717520 0.078598766   0.5943798  5.530301e-01
delta.yt_9  -0.049982364 0.078111841  -0.6398820  5.230909e-01
delta.yt_10 -0.034638353 0.078168372  -0.4431249  6.582258e-01
delta.yt_11  0.075555037 0.077993666   0.9687330  3.340230e-01
delta.yt_12  0.021863739 0.073346671   0.2980877  7.659919e-01
$T
[1] 189

$rho
[1] 0.9994567

$sigma.rho
[1] 0.004116999

$zeta
 delta.yt_1  delta.yt_2  delta.yt_3  delta.yt_4  delta.yt_5  delta.yt_6 
 0.42070173 -0.01159213  0.01343968  0.07720637 -0.03649430  0.14528224 
 delta.yt_7  delta.yt_8  delta.yt_9 delta.yt_10 delta.yt_11 delta.yt_12 
-0.09911809  0.04671752 -0.04998236 -0.03463835  0.07555504  0.02186374 

$rho.stat
[1] -0.2382095

$t.stat
[1] -0.1319633

[1] 4.249956
                Estimate  Std. Error     t value      Pr(>|t|)
(Intercept) -0.389337356 0.413800921 -0.94088084  3.480703e-01
yt_1         0.982941298 0.010766440 91.29678192 6.506909e-149
tt          -0.007384125 0.006883901 -1.07266573  2.849066e-01
delta.yt_1   0.348829755 0.074439036  4.68611329  5.595654e-06
delta.yt_2  -0.025567401 0.079110764 -0.32318485  7.469433e-01
delta.yt_3   0.002617322 0.078947706  0.03315261  9.735909e-01
delta.yt_4   0.011689457 0.080007934  0.14610372  8.840086e-01
delta.yt_5   0.099314112 0.079948258  1.24222983  2.158234e-01
delta.yt_6   0.001387289 0.080819939  0.01716518  9.863245e-01
delta.yt_7   0.063205400 0.080614348  0.78404653  4.340788e-01
delta.yt_8   0.117223384 0.080560981  1.45508883  1.474464e-01
delta.yt_9  -0.061127657 0.080788556 -0.75663757  4.502903e-01
delta.yt_10  0.081739596 0.080696462  1.01292665  3.125017e-01
delta.yt_11  0.037261364 0.080646524  0.46203311  6.446347e-01
delta.yt_12 -0.030363466 0.076740775 -0.39566275  6.928385e-01
$T
[1] 189

$rho
[1] 0.9829413

$sigma.rho
[1] 0.01076644

$zeta
  delta.yt_1   delta.yt_2   delta.yt_3   delta.yt_4   delta.yt_5   delta.yt_6 
 0.348829755 -0.025567401  0.002617322  0.011689457  0.099314112  0.001387289 
  delta.yt_7   delta.yt_8   delta.yt_9  delta.yt_10  delta.yt_11  delta.yt_12 
 0.063205400  0.117223384 -0.061127657  0.081739596  0.037261364 -0.030363466 

$rho.stat
[1] -9.112996

$t.stat
[1] -1.584433

[1] 1.489674
                 Estimate  Std. Error     t value      Pr(>|t|)
(Intercept)  0.0532014210 0.390557357  0.13621923  8.918054e-01
yt_1         0.9712932573 0.014145189 68.66597772 5.679805e-128
tt          -0.0004612496 0.003237185 -0.14248477  8.868620e-01
delta.yt_1   0.3178370194 0.074163266  4.28563944  3.010943e-05
delta.yt_2  -0.0149166870 0.078078854 -0.19104644  8.487119e-01
delta.yt_3   0.0127973250 0.077727723  0.16464299  8.694161e-01
delta.yt_4   0.0224258044 0.078676900  0.28503671  7.759550e-01
delta.yt_5   0.0845155831 0.078339518  1.07883716  2.821536e-01
delta.yt_6  -0.0030653274 0.079071534 -0.03876651  9.691210e-01
delta.yt_7   0.0299137752 0.078750797  0.37985362  7.045173e-01
delta.yt_8   0.0824197050 0.078641636  1.04804158  2.960730e-01
delta.yt_9  -0.0478615036 0.078647910 -0.60855405  5.436137e-01
delta.yt_10  0.0755667133 0.078405880  0.96378886  3.364893e-01
delta.yt_11  0.0504082264 0.078279945  0.64394816  5.204570e-01
delta.yt_12 -0.0124704308 0.075997755 -0.16408946  8.698512e-01
$T
[1] 189

$rho
[1] 0.9712933

$sigma.rho
[1] 0.01414519

$zeta
  delta.yt_1   delta.yt_2   delta.yt_3   delta.yt_4   delta.yt_5   delta.yt_6 
 0.317837019 -0.014916687  0.012797325  0.022425804  0.084515583 -0.003065327 
  delta.yt_7   delta.yt_8   delta.yt_9  delta.yt_10  delta.yt_11  delta.yt_12 
 0.029913775  0.082419705 -0.047861504  0.075566713  0.050408226 -0.012470431 

$rho.stat
[1] -13.48204

$t.stat
[1] -2.029435

[1] 2.078078

> pp.lms <- summary(lm(zt ~ zt_1 + 1, data.frame(zt = ppp.data$rer[-1], 
+     zt_1 = ppp.data$rer[-length(ppp.data$rer)])))

> PP.results <- Phillips.Perron(T = length(pp.lms$residuals), 
+     rho = pp.lms$coefficients[["zt_1", "Estimate"]], sigma.rho = pp.lms$coefficients[ .... [TRUNCATED] 

> print(pp.lms$coefficients)
              Estimate Std. Error    t value      Pr(>|t|)
(Intercept) -0.0297931 0.17835718 -0.1670418  8.675068e-01
zt_1         0.9865420 0.01275287 77.3584248 1.854719e-150

> print(PP.results)
$T
[1] 201

$rho
[1] 0.986542

$sigma.rho
[1] 0.01275287

$s.sq
[1] 6.205887

$lambda.hat.sq
[1] 13.03064

$gamma0
[1] 6.144137

$rho.stat
[1] -6.35068

$t.stat
[1] -1.706128


> ar.results <- ar(ppp.data$rer, aic = FALSE, order.max = 13, 
+     method = "ols", demean = TRUE)

> tt <- seq(1, 72)

> start.innov <- rep(0, 13)

> et <- c(start.innov, 1, rep(0, length(tt) - 14))

> arima.sim.output <- arima.sim(list(order = c(13, 0, 
+     0), ar = ar.results$ar), n = length(tt), innov = et, n.start = length(start.innov), 
+    .... [TRUNCATED] 

> irf <- as.vector(arima.sim.output)

> plot(tt[-1:-length(start.innov)], irf[-1:-length(start.innov)], 
+     type = "l", xlab = "Figure 19.4", ylab = "")

> lines(par("usr")[1:2], c(0, 0))

> poh.cointegration.lm <- lm(p ~ 1 + ner + pstar, ppp.data)

> poh.residual.lms <- summary(lm(u ~ 0 + u_1, data.frame(u = poh.cointegration.lm$residuals[-1], 
+     u_1 = poh.cointegration.lm$residuals[-length(p .... [TRUNCATED] 

> POH.results <- Phillips.Perron(T = length(poh.residual.lms$residuals), 
+     rho = poh.residual.lms$coefficients[["u_1", "Estimate"]], 
+     sigma .... [TRUNCATED] 

> print(summary(poh.cointegration.lm)$coefficients)
              Estimate  Std. Error   t value      Pr(>|t|)
(Intercept) 2.71231296 0.367695493  7.376519  4.298888e-12
ner         0.05134848 0.012045369  4.262923  3.114337e-05
pstar       0.53004097 0.006708385 79.011705 3.148050e-152

> print(poh.residual.lms$coefficients)
     Estimate Std. Error  t value     Pr(>|t|)
u_1 0.9833108 0.01171956 83.90338 7.71577e-158

> print(POH.results)
$T
[1] 201

$rho
[1] 0.9833108

$sigma.rho
[1] 0.01171956

$s.sq
[1] 0.1630028

$lambda.hat.sq
[1] 0.4082242

$gamma0
[1] 0.1621919

$rho.stat
[1] -7.542281

$t.stat
[1] -2.020981


> data(coninc, package = "Ham94")

> selection <- subset(coninc, Quarter >= "1947-01-01" & 
+     Quarter <= "1989-07-01")

> coninc.data <- data.frame(Quarter = selection$Quarter, 
+     cons = 100 * log(selection$GC82), inc = 100 * log(selection$GYD82))

> plot(coninc.data$Quarter, coninc.data$cons, type = "l", 
+     lty = 1, xlab = "Figure 19.5", ylab = "")

> lines(coninc.data$Quarter, coninc.data$inc, lty = 2)

> plot(coninc.data$Quarter, coninc.data$cons - coninc.data$inc, 
+     type = "l", lty = 1, xlab = "Figure 19.6", ylab = "")

> for (series.name in c("inc", "cons")) do.DF(series = coninc.data[[series.name]], 
+     lag = 6)
                Estimate  Std. Error     t value     Pr(>|t|)
(Intercept) 20.336729221 15.04162460  1.35203010 1.783352e-01
yt_1         0.970584904  0.02306293 42.08419931 1.029200e-86
tt           0.023796844  0.01985318  1.19864142 2.324968e-01
delta.yt_1  -0.006528755  0.08092856 -0.08067307 9.358060e-01
delta.yt_2  -0.035846316  0.08025935 -0.44663103 6.557649e-01
delta.yt_3   0.102128545  0.07758036  1.31642276 1.899755e-01
delta.yt_4  -0.187536343  0.07699406 -2.43572477 1.599577e-02
delta.yt_5  -0.037187883  0.07813842 -0.47592314 6.347992e-01
delta.yt_6   0.027855951  0.07662877  0.36351818 7.167132e-01
$T
[1] 164

$rho
[1] 0.970585

$sigma.rho
[1] 0.02306293

$zeta
  delta.yt_1   delta.yt_2   delta.yt_3   delta.yt_4   delta.yt_5   delta.yt_6 
-0.006528755 -0.035846316  0.102128545 -0.187536343 -0.037187883  0.027855951 

$rho.stat
[1] -4.242382

$t.stat
[1] -1.275428

[1] 1.132134
               Estimate  Std. Error    t value     Pr(>|t|)
(Intercept) 29.46860131 15.19248322  1.9396830 5.423391e-02
yt_1         0.95552168  0.02360001 40.4881863 2.508405e-84
tt           0.03721088  0.02006161  1.8548306 6.552012e-02
delta.yt_1   0.03624864  0.07979877  0.4542506 6.502840e-01
delta.yt_2   0.25964745  0.07935028  3.2721680 1.315743e-03
delta.yt_3   0.06273192  0.08172798  0.7675697 4.439106e-01
delta.yt_4  -0.05234112  0.08122252 -0.6444163 5.202580e-01
delta.yt_5  -0.04791625  0.07956524 -0.6022260 5.479037e-01
delta.yt_6  -0.06782142  0.07919698 -0.8563637 3.931186e-01
$T
[1] 164

$rho
[1] 0.9555217

$sigma.rho
[1] 0.02360001

$zeta
 delta.yt_1  delta.yt_2  delta.yt_3  delta.yt_4  delta.yt_5  delta.yt_6 
 0.03624864  0.25964745  0.06273192 -0.05234112 -0.04791625 -0.06782142 

$rho.stat
[1] -9.011597

$t.stat
[1] -1.884673

[1] 1.858290

> poh.cointegration.lm <- lm(cons ~ 1 + inc, coninc.data)

> poh.residual.lms <- summary(lm(u ~ 0 + u_1, data.frame(u = poh.cointegration.lm$residuals[-1], 
+     u_1 = poh.cointegration.lm$residuals[-length(p .... [TRUNCATED] 

> POH.results <- Phillips.Perron(T = length(poh.residual.lms$residuals), 
+     rho = poh.residual.lms$coefficients[["u_1", "Estimate"]], 
+     sigma .... [TRUNCATED] 

> print(summary(poh.cointegration.lm)$coefficients)
             Estimate  Std. Error     t value      Pr(>|t|)
(Intercept) 0.6675807 2.350348907   0.2840347  7.767315e-01
inc         0.9864943 0.003217444 306.6080542 5.567137e-234

> print(poh.residual.lms$coefficients)
     Estimate Std. Error  t value     Pr(>|t|)
u_1 0.7818542 0.04788553 16.32757 1.402076e-36

> print(POH.results)
$T
[1] 170

$rho
[1] 0.7818542

$sigma.rho
[1] 0.04788553

$s.sq
[1] 1.22395

$lambda.hat.sq
[1] 1.030594

$gamma0
[1] 1.216750

$rho.stat
[1] -32.04525

$t.stat
[1] -4.27529


> T <- length(coninc.data$Quarter)

> lead.lag.data <- list(ct = coninc.data$cons[c(-1:-5, 
+     -((T - 3):T))], yt = coninc.data$inc[c(-1:-5, -((T - 3):T))], 
+     delta.yt = diff(con .... [TRUNCATED] 

> no.trend.lm <- lm(ct ~ 1 + yt + delta.yt. + delta.yt + 
+     delta.yt_, lead.lag.data)

> trend.lm <- lm(ct ~ 1 + yt + tt + delta.yt. + delta.yt + 
+     delta.yt_, lead.lag.data)

> for (model in list(no.trend.lm, trend.lm)) {
+     lags <- 2
+     cms <- summary(model)
+     T <- length(cms$residuals)
+     cfs <- cms$coefficie .... [TRUNCATED] 
               Estimate  Std. Error     t value      Pr(>|t|)
(Intercept) -4.51922906 2.340224673  -1.9311091  5.534290e-02
yt           0.99215853 0.003063317 323.8837231 1.617626e-216
delta.yt.1   0.48592391 0.115704789   4.1996871  4.551158e-05
delta.yt.2   0.26411856 0.114892015   2.2988418  2.288546e-02
delta.yt.3   0.28614193 0.115594505   2.4753939  1.441397e-02
delta.yt.4   0.14530952 0.118799555   1.2231487  2.231790e-01
delta.yt    -0.24036007 0.117415901  -2.0470828  4.238356e-02
delta.yt_1  -0.01101143 0.113899420  -0.0966768  9.231113e-01
delta.yt_2   0.06969114 0.111505773   0.6250003  5.329142e-01
delta.yt_3   0.04055551 0.111155199   0.3648548  7.157303e-01
delta.yt_4   0.02150153 0.110083985   0.1953193  8.454056e-01
     Estimate Std. Error  t value     Pr(>|t|)
u_1 0.7179687 0.07722647 9.296924 1.127578e-16
u_2 0.2057401 0.07684783 2.677241 8.207043e-03
[1] 162
[1] 1.516006
[1] -2.559799
[1] 0.3809180
[1] 8.089864
[1] -0.4796954
                Estimate  Std. Error    t value     Pr(>|t|)
(Intercept) 198.87166510 15.01478288 13.2450577 5.215628e-27
yt            0.68117915  0.02292367 29.7150967 9.919458e-65
tt            0.26895671  0.01974617 13.6207037 5.213974e-28
delta.yt.1    0.40061828  0.07787309  5.1445023 8.270282e-07
delta.yt.2    0.15407283  0.07749787  1.9880910 4.862147e-02
delta.yt.3    0.16559666  0.07805023  2.1216678 3.550904e-02
delta.yt.4    0.02782397  0.08016237  0.3470952 7.290063e-01
delta.yt     -0.05124600  0.07998305 -0.6407108 5.226882e-01
delta.yt_1    0.12737594  0.07708222  1.6524685 1.005308e-01
delta.yt_2    0.23116996  0.07573754  3.0522506 2.687346e-03
delta.yt_3    0.20472613  0.07553655  2.7102923 7.505953e-03
delta.yt_4    0.18997478  0.07487875  2.5370986 1.219919e-02
     Estimate Std. Error  t value     Pr(>|t|)
u_1 0.6871713 0.07786238 8.825460 1.937474e-15
u_2 0.1291820 0.07666487 1.685022 9.395837e-02
[1] 162
[1] 1.017016
[1] -13.90793
[1] 0.3439489
[1] 3.193478
[1] -4.429212

#######################
### p5.R 
#######################

> phi <- 0.8

> T <- 20

> w <- 1 * cbind(1:T == 6, 1:T >= 6)

> y <- array(dim = c(T, 2))

> y[1:5, ] <- 0

> for (j in 6:T) y[j, ] <- phi * y[j - 1, ] + w[j, ]

> screens <- split.screen(figs = c(2, 2))

> for (i in 1:2) {
+     screen(n = screens[[2 * (i - 1) + 1]], new = TRUE)
+     top <- max(w[, i], y[, ])
+     plot(1:T, w[, i], type = "h", xlab = .... [TRUNCATED] 

> close.screen(all = TRUE)

#######################
### p647.R 
#######################

> data(ppp, package = "RcompHam94")

> selection <- subset(ppp, Month >= "1973-01-01" & Month <= 
+     "1989-10-01")

> ppp.data <- data.frame(pstar = 100 * log(selection$PC6IT/selection$PC6IT[[1]]), 
+     p = 100 * log(selection$PZUNEW/selection$PZUNEW[[1]]), ner =  .... [TRUNCATED] 

> y <- as.matrix(ppp.data)

> delta.y <- diff(y)

> lags <- 12

> X <- embed(delta.y[-dim(delta.y)[[1]], ], lags)

> T <- dim(X)[[1]]

> n <- dim(y)[[2]]

> lhs <- cbind(delta.y[-1:(-lags), ], y[c(-1:-lags, 
+     -(T + lags + 1)), ])

> aux.lm <- lm(lhs ~ 1 + X, list(lhs = lhs, X = X))

> uv <- sapply(summary(aux.lm), FUN = function(x) {
+     x$residuals
+ })

> u <- uv[, 1:n]

> v <- uv[, (n + 1):(2 * n)]

> SigmaUU <- 1/T * t(u) %*% u

> SigmaVV <- 1/T * t(v) %*% v

> SigmaUV <- 1/T * t(u) %*% v

> eigen.results <- eigen(solve(SigmaVV) %*% t(SigmaUV) %*% 
+     solve(SigmaUU) %*% SigmaUV)

> lambda <- eigen.results$values

> LRT <- -T * sum(log(1 - lambda))

> print(SigmaUU)
               Response pstar  Response p Response ner
Response pstar     0.17931504  0.01531134   0.02715177
Response p         0.01531134  0.04341512  -0.03267373
Response ner       0.02715177 -0.03267373   4.60842626

> print(SigmaVV)
               Response pstar Response p Response ner
Response pstar      1503.5545   794.7041    -697.4981
Response p           794.7041   421.5535    -365.1883
Response ner        -697.4981  -365.1883     414.1322

> print(SigmaUV)
               Response pstar Response p Response ner
Response pstar     -3.5787320 -1.7958934    1.5095381
Response p         -0.8602478 -0.4969721    0.5243431
Response ner       -3.1461173 -2.0636489   -2.2685853

> print(lambda)
[1] 0.12002316 0.05077020 0.03174158

> print(T * log(1 - lambda))
[1] -24.165480  -9.847724  -6.096434

> print(LRT)
[1] 40.10964

> ahat1 <- eigen.results$vectors[, 1]

> ahat1.tilde <- ahat1/sqrt(t(ahat1) %*% SigmaVV %*% 
+     ahat1)

> ahat1.normal <- ahat1/ahat1[[1]]

> print(ahat1)
[1] -0.48885151  0.87144476 -0.04010268

> print(ahat1.tilde)
[1] -0.44788450  0.79841545 -0.03674197

> print(ahat1.normal)
[1]  1.00000000 -1.78263694  0.08203448

> D = cbind(c(1, 0, 0), c(0, 0, 1))

> SigmaVV.tilde <- t(D) %*% SigmaVV %*% D

> SigmaUV.tilde <- SigmaUV %*% D

> eigen.results <- eigen(solve(SigmaVV.tilde) %*% t(SigmaUV.tilde) %*% 
+     solve(SigmaUU) %*% SigmaUV.tilde)

> lambda.tilde <- eigen.results$values

> h <- 1

> LRT <- -T * sum(log(1 - lambda[1:h])) + T * sum(log(1 - 
+     lambda.tilde[1:h]))

> ahat1.normal.tilde <- eigen.results$vectors[, 1]/eigen.results$vectors[, 
+     1][[1]]

> print(SigmaVV.tilde)
          [,1]      [,2]
[1,] 1503.5545 -697.4981
[2,] -697.4981  414.1322

> print(SigmaUV.tilde)
                     [,1]       [,2]
Response pstar -3.5787320  1.5095381
Response p     -0.8602478  0.5243431
Response ner   -3.1461173 -2.2685853

> print(lambda.tilde)
[1] 0.05828948 0.03295258

> print(T * log(1 - lambda.tilde))
[1] -11.350839  -6.332964

> print(LRT)
[1] 12.81464

> print(ahat1.normal.tilde)
[1] 1.000000 1.012463

> h <- 1

> D = c(1, -1, -1) %o% 1

> SigmaVV.tilde <- t(D) %*% SigmaVV %*% D

> SigmaUV.tilde <- SigmaUV %*% D

> eigen.results <- eigen(solve(SigmaVV.tilde) %*% t(SigmaUV.tilde) %*% 
+     solve(SigmaUU) %*% SigmaUV.tilde)

> lambda.tilde <- eigen.results$values

> LRT <- -T * sum(log(1 - lambda[1:h])) + T * sum(log(1 - 
+     lambda.tilde[1:h]))

> print(SigmaVV.tilde)
         [,1]
[1,] 1414.452

> print(SigmaUV.tilde)
                     [,1]
Response pstar -3.2923768
Response p     -0.8876187
Response ner    1.1861170

> print(lambda.tilde)
[1] 0.04912925

> print(T * log(1 - lambda.tilde))
[1] -9.521278

> print(LRT)
[1] 14.64420

#######################
### p660.R 
#######################

> arch.fitted.values <- function(THETA, YT) {
+     alpha <- THETA[grep("alpha.*", names(THETA))]
+     beta <- THETA[grep("beta.*", names(THETA))]
+  .... [TRUNCATED] 

> arch.standard.errors <- function(THETA, YT) {
+     x <- YT$x
+     y <- YT$y
+     k <- dim(x)[[2]]
+     alpha <- THETA[grep("alpha.*", names(THET .... [TRUNCATED] 

> arch.normal <- function(THETA, YT) {
+     fv <- arch.fitted.values(THETA, YT)
+     m <- length(THETA[grep("alpha.*", names(THETA))])
+     h <- fv .... [TRUNCATED] 

> arch.scaled.t <- function(THETA, YT) {
+     fv <- arch.fitted.values(THETA, YT)
+     m <- length(THETA[grep("alpha.*", names(THETA))])
+     h <-  .... [TRUNCATED] 

> GMM.estimates <- function(YT, h, THETA, S) {
+     g <- function(YT, THETA) {
+         apply(X = apply(X = YT, MARGIN = 1, FUN = h, THETA = THETA), .... [TRUNCATED] 

> data(fedfunds, package = "RcompHam94")

> selection <- subset(fedfunds, Month >= "1955-01-01" & 
+     Month <= "2000-12-01")

> y <- selection$FFED

> plot(selection$Month, y, type = "l", lty = 1, xlab = "Figure 21.1 - US Fed Funds Rate", 
+     ylab = "")

> y.lm <- lm(y ~ 1 + y_1, list(y = y[-1], y_1 = y[-length(y)]))

> u <- y.lm$residuals

> u2.lm <- lm(u2 ~ 1 + u2_lag, list(u2 = u[-1:-4]^2, 
+     u2_lag = embed(u[-length(u)]^2, 4)))

> F34 <- Wald.F.Test(R = cbind(rep(0, 2) %o% rep(0, 
+     3), diag(2)), b = u2.lm$coefficients, r = c(0, 0), s2 = summary(u2.lm)$sigma^2, 
+     XtX_ .... [TRUNCATED] 

> F34.sig <- 1 - pf(F34, 2, length(u2.lm$residuals) - 
+     u2.lm$rank)

> F234 <- Wald.F.Test(R = cbind(rep(0, 3) %o% rep(0, 
+     2), diag(3)), b = u2.lm$coefficients, r = c(0, 0, 0), s2 = summary(u2.lm)$sigma^2, 
+      .... [TRUNCATED] 

> F234.sig <- 1 - pf(F234, 3, length(u2.lm$residuals) - 
+     u2.lm$rank)

> accept.arch <- pchisq(length(u2.lm$residuals) * summary(u2.lm)$r.squared, 
+     4)

> print(F34)
[1] 0.8225742

> print(F34.sig)
[1] 0.439847

> print(F234)
[1] 11.88167

> print(F234.sig)
[1] 1.513714e-07

> print(accept.arch)
[1] 1

> YT <- list(y = y[-1], x = cbind(rep(1, length(y) - 
+     1), y[-length(y)]))

> THETA <- c(beta = y.lm$coefficients, zeta = var(y.lm$residuals), 
+     alpha = c(0.1, 0.1))

> optimizer.results <- optim(par = THETA, fn = arch.normal, 
+     gr = NULL, YT = YT)

> print(optimizer.results$par)
beta.(Intercept)         beta.y_1             zeta           alpha1 
      0.25226382       0.94858488       0.02734929       0.95530391 
          alpha2 
      0.29858866 

> se <- arch.standard.errors(optimizer.results$par, 
+     YT)

> print(se)
[1] 0.048395622 0.010418563 0.004969357 0.108784800 0.082012310

> h <- function(wt, THETA) {
+     beta <- THETA[grep("beta.*", names(THETA))]
+     zeta <- THETA["zeta"]
+     alpha <- THETA[grep("alpha.*", names( .... [TRUNCATED] 

> S.estimator <- function(ht) {
+     1/dim(ht)[[1]] * t(ht) %*% ht
+ }

> THETA <- c(beta = y.lm$coefficients, zeta = var(y.lm$residuals), 
+     alpha = c(0.1, 0.1))

> m <- length(THETA[grep("alpha.*", names(THETA))])

> T <- length(YT$y) - m

> w <- as.matrix(data.frame(yt = YT$y[-1:-m], xt = YT$x[-1:-m, 
+     ], ylagt = embed(YT$y[-(T + m)], m), xlagt = embed(YT$x[-(T + 
+     m), ], m)))

> estimates <- GMM.estimates(YT = w, h = h, THETA = THETA, 
+     S.estimator)

> print(estimates$stage.1.results$par)
beta.(Intercept)         beta.y_1             zeta           alpha1 
      0.05788674       0.98955937       0.32491651       0.01073606 
          alpha2 
      0.02105476 

> print(estimates$stage.2.results$par)
beta.(Intercept)         beta.y_1             zeta           alpha1 
      0.02579794       0.99791508      -0.17911928       0.01239927 
          alpha2 
      0.07770754 

#######################
### p697.R 
#######################

> data(gnpdata, package = "RcompHam94")

> selection <- subset(gnpdata, Quarter >= "1951-01-01" & 
+     Quarter <= "1984-04-01")

> d <- selection$Quarter[-1]

> g <- diff(100 * log(selection$GNP), lag = 1, differences = 1)

> nlags <- 4

> nstates <- 2^(nlags + 1)

> lagstate <- 1 + outer(1:nstates, 1:(nlags + 1), FUN = function(i, 
+     j) {
+     trunc((i - 1)/2^(nlags + 1 - j))%%2
+ })

> transit <- outer(X = 1:nstates, Y = 1:nstates, FUN = function(i, 
+     j) {
+     ((2 * lagstate[i, 1] + lagstate[j, 1] - 1) - 1) * (((i - 
+       .... [TRUNCATED] 

> infer.regimes <- function(THETA, YT) {
+     phi <- THETA[grep("phi*", names(THETA))]
+     mu <- THETA[grep("mu*", names(THETA))]
+     sigma <- TH .... [TRUNCATED] 

> g.lm <- lm(g ~ 1 + g_lag, list(g = g[-1:-nlags], g_lag = embed(g[-length(g)], 
+     nlags)))

> THETA <- c(p11star = 0.85, p22star = 0.7, mu = c(1, 
+     0), phi = as.vector(g.lm$coefficients[1 + (1:nlags)]), sigma = summary(g.lm)$sigma)

> objective <- function(THETA, YT) {
+     -infer.regimes(THETA, YT)$log.likelihood
+ }

> optimizer.results <- optim(par = THETA, hessian = TRUE, 
+     fn = objective, gr = NULL, YT = g)

> se <- diag(solve(optimizer.results$hessian))^0.5

> print(optimizer.results$par)
     p11star      p22star          mu1          mu2         phi1         phi2 
 0.869651020  0.657920015  1.095327317 -0.198544833  0.311107386  0.092829514 
        phi3         phi4        sigma 
-0.125038400 -0.007166502  0.872625052 

> print(se)
   p11star    p22star        mu1        mu2       phi1       phi2       phi3 
0.13323951 0.04404274 0.23169921        NaN 0.08762475 0.10748667 0.09374541 
      phi4      sigma 
0.08826466        NaN 

> regimes <- infer.regimes(optimizer.results$par, g)

> recession.probability <- as.vector((1:nstates > nstates/2) %*% 
+     regimes$xi.t.t)

> smoothed.recession.probability <- as.vector((1:nstates > 
+     nstates/2) %*% regimes$xi.t.T)

> flags.to.start.stop <- function(flags) {
+     n <- length(flags)
+     starts <- (flags - c(-1, flags[-n])) == 2
+     ends <- (c(flags[-1], 1) - f .... [TRUNCATED] 

> screens <- split.screen(figs = c(3, 1))

> screen(n = screens[[1]], new = TRUE)

> par(mar = c(4, 2, 1, 2), cex = 0.75)

> pairs <- flags.to.start.stop(selection$RECESSQ)

> plot(d, g, type = "l", lty = 1, xlab = "Figure 22.4a", 
+     ylab = "")

> usr <- par()$usr

> lines(c(d[1], d[length(g)]), c(0, 0), lty = 1)

> rect(d[pairs[, 1]], rep(usr[3], dim(pairs)[[1]]), 
+     d[pairs[, 2]], rep(usr[4], dim(pairs)[[1]]))

> screen(n = screens[[2]], new = TRUE)

> par(mar = c(4, 2, 1, 2), cex = 0.75)

> plot(d, recession.probability, type = "l", lty = 1, 
+     xlab = "Figure 22.4b", ylab = "")

> usr <- par()$usr

> lines(c(d[1], d[length(g)]), c(0, 0), lty = 1)

> rect(d[pairs[, 1]], rep(usr[3], dim(pairs)[[1]]), 
+     d[pairs[, 2]], rep(usr[4], dim(pairs)[[1]]))

> screen(n = screens[[3]], new = TRUE)

> par(mar = c(4, 2, 1, 2), cex = 0.75)

> plot(d, smoothed.recession.probability, type = "l", 
+     lty = 1, xlab = "Smoothed recession probabilities", ylab = "")

> usr <- par()$usr

> lines(c(d[1], d[length(g)]), c(0, 0), lty = 1)

> rect(d[pairs[, 1]], rep(usr[3], dim(pairs)[[1]]), 
+     d[pairs[, 2]], rep(usr[4], dim(pairs)[[1]]))

> close.screen(all = TRUE)

Il y a eu 50 avis ou plus (utilisez warnings() pour voir les 50 premiers)
> 
> unlink("./Rplots.pdf")
> 
> proc.time()
utilisateur     système      écoulé 
    336.300       5.860     223.914 
