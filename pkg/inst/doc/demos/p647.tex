\begin{Schunk}
\begin{Sinput}
> library("Ham94", lib.loc = "../../../library")
\end{Sinput}
\end{Schunk}
Section 20.3 reanalyzes the data used in Chapter 19 using the FIML approach. 
\begin{Schunk}
\begin{Sinput}
> data(ppp, package = "Ham94")
> selection <- subset(ppp, Month >= "1973-01-01" & Month <= "1989-10-01")
> ppp.data <- data.frame(pstar = 100 * log(selection$PC6IT/selection$PC6IT[[1]]), 
+     p = 100 * log(selection$PZUNEW/selection$PZUNEW[[1]]), ner = -100 * 
+         log(selection$EXRITL/selection$EXRITL[[1]]))
> y <- as.matrix(ppp.data)
\end{Sinput}
\end{Schunk}
First conduct the auxiliary regressions.  Given that the right hand sides consists of lagged values of the changes in y
for both [20.2.4] and [20.2.5], construct a regression with both lagged y and lagged changes of y as left hand side.
\begin{Schunk}
\begin{Sinput}
> delta.y <- diff(y)
> lags <- 12
> X <- embed(delta.y[-dim(delta.y)[[1]], ], lags)
> T <- dim(X)[[1]]
> n <- dim(y)[[2]]
> lhs <- cbind(delta.y[-1:(-lags), ], y[c(-1:-lags, -(T + lags + 
+     1)), ])
> aux.lm <- lm(lhs ~ 1 + X, list(lhs = lhs, X = X))
> uv <- sapply(summary(aux.lm), FUN = function(x) {
+     x$residuals
+ })
> u <- uv[, 1:n]
> v <- uv[, (n + 1):(2 * n)]
\end{Sinput}
\end{Schunk}
Now calculate the canonical correlations according to [20.2.6], [20.2.7], [20.2.8],
and calculate eigenvalues according to [20.2.9], and log likelihood as in [20.2.10].
Note that u is T rows by n columns
so that ut is the t-th row of matrix u, so only a single inner product, rather than sum of outer products, is needed.
\begin{Schunk}
\begin{Sinput}
> SigmaUU <- 1/T * t(u) %*% u
> SigmaVV <- 1/T * t(v) %*% v
> SigmaUV <- 1/T * t(u) %*% v
> eigen.results <- eigen(solve(SigmaVV) %*% t(SigmaUV) %*% solve(SigmaUU) %*% 
+     SigmaUV)
> lambda <- eigen.results$values
> LRT <- -T * sum(log(1 - lambda))
> print(SigmaUU)
\end{Sinput}
\begin{Soutput}
               Response pstar  Response p Response ner
Response pstar     0.17931504  0.01531134   0.02715177
Response p         0.01531134  0.04341512  -0.03267373
Response ner       0.02715177 -0.03267373   4.60842626
\end{Soutput}
\begin{Sinput}
> print(SigmaVV)
\end{Sinput}
\begin{Soutput}
               Response pstar Response p Response ner
Response pstar      1503.5545   794.7041    -697.4981
Response p           794.7041   421.5535    -365.1883
Response ner        -697.4981  -365.1883     414.1322
\end{Soutput}
\begin{Sinput}
> print(SigmaUV)
\end{Sinput}
\begin{Soutput}
               Response pstar Response p Response ner
Response pstar     -3.5787320 -1.7958934    1.5095381
Response p         -0.8602478 -0.4969721    0.5243431
Response ner       -3.1461173 -2.0636489   -2.2685853
\end{Soutput}
\begin{Sinput}
> print(lambda)
\end{Sinput}
\begin{Soutput}
[1] 0.12002316 0.05077020 0.03174158
\end{Soutput}
\begin{Sinput}
> print(T * log(1 - lambda))
\end{Sinput}
\begin{Soutput}
[1] -24.165480  -9.847724  -6.096434
\end{Soutput}
\begin{Sinput}
> print(LRT)
\end{Sinput}
\begin{Soutput}
[1] 40.10964
\end{Soutput}
\end{Schunk}
Finally following page 648, calculate the first cointegrating vector normalized as in [20.3.9], and also
normalized to have unity for the first coefficient.
\begin{Schunk}
\begin{Sinput}
> ahat1 <- eigen.results$vectors[, 1]
> ahat1.tilde <- ahat1/sqrt(t(ahat1) %*% SigmaVV %*% ahat1)
> ahat1.normal <- ahat1/ahat1[[1]]
> print(ahat1)
\end{Sinput}
\begin{Soutput}
[1] -0.48885151  0.87144476 -0.04010268
\end{Soutput}
\begin{Sinput}
> print(ahat1.tilde)
\end{Sinput}
\begin{Soutput}
[1] -0.44788450  0.79841545 -0.03674197
\end{Soutput}
\begin{Sinput}
> print(ahat1.normal)
\end{Sinput}
\begin{Soutput}
[1]  1.00000000 -1.78263694  0.08203448
\end{Soutput}
\end{Schunk}
\subsection{Likelihood Ratio Tests on the Cointegration Vector}
Page 649 shows how to conduct hypothesis tests on the cointegration vector.  The follow code implements
[20.3.10] - [20.3.14] and subsequent calculations.
\begin{Schunk}
\begin{Sinput}
> D = cbind(c(1, 0, 0), c(0, 0, 1))
> SigmaVV.tilde <- t(D) %*% SigmaVV %*% D
> SigmaUV.tilde <- SigmaUV %*% D
> eigen.results <- eigen(solve(SigmaVV.tilde) %*% t(SigmaUV.tilde) %*% 
+     solve(SigmaUU) %*% SigmaUV.tilde)
> lambda.tilde <- eigen.results$values
> h <- 1
> LRT <- -T * sum(log(1 - lambda[1:h])) + T * sum(log(1 - lambda.tilde[1:h]))
> ahat1.normal.tilde <- eigen.results$vectors[, 1]/eigen.results$vectors[, 
+     1][[1]]
> print(SigmaVV.tilde)
\end{Sinput}
\begin{Soutput}
          [,1]      [,2]
[1,] 1503.5545 -697.4981
[2,] -697.4981  414.1322
\end{Soutput}
\begin{Sinput}
> print(SigmaUV.tilde)
\end{Sinput}
\begin{Soutput}
                     [,1]       [,2]
Response pstar -3.5787320  1.5095381
Response p     -0.8602478  0.5243431
Response ner   -3.1461173 -2.2685853
\end{Soutput}
\begin{Sinput}
> print(lambda.tilde)
\end{Sinput}
\begin{Soutput}
[1] 0.05828948 0.03295258
\end{Soutput}
\begin{Sinput}
> print(T * log(1 - lambda.tilde))
\end{Sinput}
\begin{Soutput}
[1] -11.350839  -6.332964
\end{Soutput}
\begin{Sinput}
> print(LRT)
\end{Sinput}
\begin{Soutput}
[1] 12.81464
\end{Soutput}
\begin{Sinput}
> print(ahat1.normal.tilde)
\end{Sinput}
\begin{Soutput}
[1] 1.000000 1.012463
\end{Soutput}
\end{Schunk}
Page 650 shows a second example.
\begin{Schunk}
\begin{Sinput}
> h <- 1
> D = c(1, -1, -1) %o% 1
> SigmaVV.tilde <- t(D) %*% SigmaVV %*% D
> SigmaUV.tilde <- SigmaUV %*% D
> eigen.results <- eigen(solve(SigmaVV.tilde) %*% t(SigmaUV.tilde) %*% 
+     solve(SigmaUU) %*% SigmaUV.tilde)
> lambda.tilde <- eigen.results$values
> LRT <- -T * sum(log(1 - lambda[1:h])) + T * sum(log(1 - lambda.tilde[1:h]))
> print(SigmaVV.tilde)
\end{Sinput}
\begin{Soutput}
         [,1]
[1,] 1414.452
\end{Soutput}
\begin{Sinput}
> print(SigmaUV.tilde)
\end{Sinput}
\begin{Soutput}
                     [,1]
Response pstar -3.2923768
Response p     -0.8876187
Response ner    1.1861170
\end{Soutput}
\begin{Sinput}
> print(lambda.tilde)
\end{Sinput}
\begin{Soutput}
[1] 0.04912925
\end{Soutput}
\begin{Sinput}
> print(T * log(1 - lambda.tilde))
\end{Sinput}
\begin{Soutput}
[1] -9.521278
\end{Soutput}
\begin{Sinput}
> print(LRT)
\end{Sinput}
\begin{Soutput}
[1] 14.64420
\end{Soutput}
\end{Schunk}
